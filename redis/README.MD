# Redis

## 一、5种对象的底层编码

每次往redis数据库插入一个键值对时，redis服务器至少会创建2个对象，一个是存放key的健对象，一个是存放value的值对象。

其中键对象只能是字符串对象，而值对象则可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象中的一种。每种类型的对象都至少使用了两种不同的编码，每种类型的编码如下：

![img](.img/epub_622000_88.jpeg)

可以使用命令`OBJECT ENCODING key_name`查看某个键的编码

```bash
$ set msg "hello"
$ OBJECT ENCODING msg
"embstr"
```

### (1) 字符串对象 | string

- int

  redis在服务器初始化时，会创建0-9999的共享变量，这些共享变量是为了提高redis对这些数据的访问速度
- raw

  **字符串值的长度大于32字节**，简单动态字符串（SDS）
- embstr（只读的）

  **字符串值的长度大于32字节**，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw

#### 1）embstr相比raw编码格式的优点：

- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
- 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。
- 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势（**因为缓存是读取一块连续内存中的数据**）。

embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用`redisObject`结构和`sdshdr`结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建`redisObject`结构和`sdshdr`结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，**空间中依次包含`redisObject`和`sdshdr`两个结构**

以下是embstr编码创建的内存结构：

![img](.img/epub_622000_93.jpeg)

以下是raw编码创建的内存结构：

![img](.img/epub_622000_92.jpeg)

#### 2）浮点类型的数字在redis也是以字符串的形式存储

- long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。

- 需要取出这个数据的时候，会将其转换成浮点类型的数字返回

#### 3）embstr编码的字符串是只读的

Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象

#### 4）int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象

```bash
$ set num 1
OK
$ OBJECT ENCODING num
"int"
$ append num " is a num"
OK
$ OBJECT ENCODING num
"raw"
```

因为embstr编码是只读的，所以只要对其进行修改了，就会将smbstr编码格式的字符串转成raw编码的字符串。

### (2) 列表对象 | list

- 双端列表，linkedlist
  - 列表对象保存的元素中有**元素长度大于64字节**；
  - 列表对象保存的元素数量**大于等于512个；**

- 压缩列表，ziplist
  - 列表对象保存的**所有**字符串元素的**长度都小于64字节**；
  - 列表对象保存的**元素数量小于512个**；
  - 以上两个条件的上限值是可以修改的，具体看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。


**如果列表对象中的保存到元素不能满足存储压缩列表的条件时，redis会将该列表对象的底层实现从ziplist自动转成linkedlist编码格式。**

#### 1）压缩列表的内存结构

![img](.img/epub_622000_97.jpeg)

#### 2）双端队列的内存结构

![img](.img/epub_622000_98.jpeg)

### (3) 哈希对象 | hash

- 字典，hashtable
- 压缩列表，ziplist
  - 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；（可以修改配置文件中的hash-max-ziplist-value选项修改具体的值）
  - 哈希对象保存的键值对数量小于512个；（可以通过修改配置文件中的hash-max-ziplist-entries选项修改具体的值）

#### 1）hashtable存储哈希的内存结构

![img](.img/epub_622000_104.jpeg)

#### 2）压缩列表存储哈希的内存结构

压缩列表中新增的节点总是会在列表的尾部：

- 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向

![img](.img/epub_622000_102.jpeg)

![img](.img/epub_622000_103.jpeg)

### (4) 集合对象 | set

- 整数集合，intset
  - 集合对象保存的所有元素都是整数值；
  - 集合对象保存的元素数量不超过512个。（可以通过配置文件中的set-max-intset-entries选项修改具体的值）

- 字典，hashtable
  - hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。


#### 1）intset编码格式存储集合对象的内存结构

![img](.img/epub_622000_106.jpeg)

#### 2）hashtable编码格式存储集合对象的内存结构

![img](.img/epub_622000_107.jpeg)

### (5) 有序集合对象 | zset

- 压缩列表，ziplist
  - 每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）
  - 压缩列表内的集合元素按分值**从小到大进行排序**，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向
  - 有序集合保存的元素数量小于128个；（zset-max-ziplist-entries）
  - 有序集合保存的所有元素成员的长度都小于64字节；（zset-max-ziplist-value）

- 跳表，skiplist

#### 1）压缩列表的内存结构

![img](.img/epub_622000_109.jpeg)

![img](.img/epub_622000_110.jpeg)

2）跳表的内存结构

![img](.img/epub_622000_111.jpeg)

![img](.img/epub_622000_112.jpeg)

> **为什么有序集合需要同时使用跳跃表和字典来实现？**
>
> 在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。
>
> 另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

## 二、底层数据结构





1. [如何用redis实现分布式锁](./%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md)

