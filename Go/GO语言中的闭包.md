## 1 为什么会有闭包

在介绍闭包之前，需要先了解**全局变量**和**局部变量**：

- 全局变量：
  - 常驻内存
  - 污染全局
- 局部变量：
  - 不常驻内存
  - 不污染全局

而GO语言的闭包可以做到以下2点：

1. 可以让变量常驻内存
2. 可以让变量不污染全局

**闭包主要是为了避免全局变量的滥用**

> 什么叫污染全局？
>
> 污染全局就是在不同的地方定义了相同名称的全局变量，也就是命名冲突，导致全局变量取值混乱。
>
> 在生产环境如果别人定义了全局变量`a`，我们在不知道的情况下，也定义了一个全局变量`a`，有可能会覆盖别人的值，导致程序错误。

## 2 闭包

### 2.1 什么是闭包

1. 闭包是指有权访问另一个函数作用域中的变量的**函数**
2. 创建闭包的常见方式就是在一个函数内部常见另一个函数，**内函数**可以访问**外函数**的变量

注意：闭包里作用域返回的**局部变量**不会被立刻销毁回收，但**过度使用**闭包可能会占用更多内存，导致**性能下降**。

### 2.2 举例说明

```go
func adder() func()int{
    i := 10
    return func()int{
        return i + 1
    }
}

func adder1() func(x int)int{
    i := 10
    return func(x int)int{
        i = i + x
        return i
    }
}

func main() {
    fn := adder()
    fmt.Println(fn())  //11
    fmt.Println(fn())  //11

    fn1 := adder1()
    fmt.Println(fn1(10))  //20  这里改变了adder1中定义的局部变量x
    fmt.Println(fn1(10))  //30
}
```

对adder1的总结：

1. adder1是一个函数，返回的数据类型是`func(int) int`
2. adder1就是闭包，返回的是一个匿名函数，但是这个匿名函数引用到函数外面的`i`，因此这个匿名函数就和`i`形成一个整体，构成闭包。
3. 可以这样理解：闭包是类，函数是操作，`i`是字段，函数和他使用的变量构成闭包
4. 当我们反复调用`fn1`函数时，因为`i`是**只**初始化一次，因此每调用一次就进行累计一次。
5. 搞清楚闭包的关键就是分析出返回的函数和他引用到哪些变量。

## Reference

1. https://www.jianshu.com/p/a12f8c3eb98c
2. https://blog.csdn.net/qq_27654007/article/details/116667624