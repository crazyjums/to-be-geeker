# 在浏览器地址栏输入一个`URL`后回车，背后会进行哪些技术步骤

![img](.img/v2-a069ac8daaf04686fb59bc3cbb175cf9_720w.webp)

## 1 检车`URL`地址是否合法

### （1）检查`URL`格式

浏览器会先检查用户输入的`URL`是否是一个格式合法的`URL`地址，如果`URL`不合法，则会提示用户输入有误（现在的浏览器，可能将一个非法的`URL`当成搜索内容去浏览器指定的搜索引擎搜索结果并返回）

![img](.img/v2-783a91ad19e306a0c6889b0eac84d314_720w.webp)

### （2）检查协议

如果用户输入的`URL`没有指定协议（`HTTP`/`HTTPS`），则浏览器默认使用`HTTP`协议发送请求，除非用户指定用`HTTPS`协议

## 2 生成`HTTP`协议请求信息

![img](.img/v2-f04d2ecb980232d5601f8ed8b0e19d74_720w.webp)

## 3 将域名解析成`IP`地址

因为`TCP`/`IP`协议只能识别`IP`地址，不能识别域名，所以这一步需要将``URL``解析成`IP`地址

域名的层级关系：

- 根 `DNS `服务器
- 顶级域 `DNS `服务器（com）
- 权威 `DNS `服务器（server.com）

![img](.img/v2-1352f5eee6c13130aaa4204def00ae80_720w.png)

DNS解析流程：

1. 客户端首先会发出一个 `DNS` 请求，问 `HTTP`://www.server.com的 `IP` 是啥，并发给本地 `DNS` 服务器（也就是客户端的 ``TCP`/`IP`` 设置中填写的 `DNS` 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存（先查找内存中是否缓存，如果没有，则查找本地hosts文件是否有）里的表格能找到 `HTTP`://www.server.com，则它直接返回 `IP` 地址。如果没有，本地 `DNS` 会去问它的根域名服务器：“老大， 能告诉我 `HTTP`://www.server.com的 `IP` 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 `DNS` 收到来自本地 `DNS` 的请求后，发现后置是 `.com`，说：“`HTTP`://www.server.com这个域名归 .com 区域管理”，我给你 `.com` 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 `DNS` 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 `HTTP`://www.server.com的 `IP` 地址吗？”
5. 顶级域名服务器说：“我给你负责 [`HTTP`://www.server.com](`HTTP`s://link.zhihu.com/?target=`HTTP`%3A//www.server.com) 区域的权威 `DNS` 服务器的地址，你去问它应该能问到”。
6. 本地 `DNS` 于是转向问权威 `DNS` 服务器：“老三，`HTTP`://www.server.com对应的`IP`是啥呀？” `HTTP`://server.com的权威 `DNS` 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 `DNS` 服务器查询后将对应的 `IP` 地址 `X.X.X.X` 告诉本地 `DNS`。
8. 本地 `DNS` 再将 `IP` 地址返回客户端，客户端和目标建立连接。

![img](.img/v2-0a69a9e03a6e31d3aaa1af588055d9e0_720w.webp)

## 4 OSI七层协议数据封装

通过 `DNS` 获取到 `IP` 后，就可以把 ``HTTP`` 的传输工作交给操作系统中的**协议栈]**。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。

![img](.img/v2-9288761c8783b6daed2ef2bee366d249_1440w.webp)

应用程序（浏览器）通过调用 `Socket` 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 ``TCP`` 和 `UDP` 协议，它们两会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 `IP` 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将[网络包](`HTTP`s://www.zhihu.com/search?q=网络包&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})发送给对方的操作就是由 `IP` 负责的。

此外 `IP` 中还包括 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 `IP` 地址查询相应的[以太网](`HTTP`s://www.zhihu.com/search?q=以太网&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394}) `MAC `地址。

`IP` 下面的网卡[驱动程序](`HTTP`s://www.zhihu.com/search?q=驱动程序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

### （1）`TCP`协议 | 传输层

`HTTP` 是基于 `TCP` 协议传输的，所以在这我们先了解下 `TCP` 协议。

> `TCP` 报文头格式

我们先看看 `TCP` 报文头部的格式：

![img](.img/v2-f4c41ab33f3b5b22908a6330c0bb23df_1440w.webp)

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN`是结束连接等。`TCP` 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。`TCP` 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，`TCP`还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

#### ① `TCP`三次握手-建立连接

在 `HTTP` 传输数据之前，首先需要 `TCP` 建立连接，`TCP` 连接的建立，通常称为**三次握手**。

这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。

![img](.img/v2-c1b7415f0eee5cf04ec01218a976c7bf_1440w.webp)

一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。

然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。

服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。

客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送 `ACK` 的 `ACK`，之后处于 `ESTABLISHED`状态，因为它一发一收成功了。

服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

所以三次握手目的是**保证双方都有发送和接收的能力**。

#### ② 如何查看 `TCP` 的连接状态？

`TCP` 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![img](.img/v2-c2705e8698ff55a3d8e24addab283ec1_1440w.webp)

#### ③ `TCP` 分割数据

如果 `HTTP` 请求消息比较长，超过了 `MSS` 的长度，这时 `TCP` 就需要把 `HTTP` 的数据拆解一块块的数据发送，而不是一次性发送所有数据。

![img](.img/v2-60111facd139b927c9b5fd15b5155d4e_1440w.webp)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 `IP` 和 `TCP` 头部之后，一个网络包所能容纳的 `TCP` 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 `TCP` 头信息，然后交给 `IP` 模块来发送数据。

![img](.img/v2-35fac77a6333b20766cf179ca73516b8_1440w.webp)

#### ④ `TCP` 报文生成

`TCP` 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（`HTTP` 默认端口号是 `80`， `HTTP`S 默认端口号是 `443`）。

在双方建立了连接后，`TCP` 报文中的数据部分就是存放 `HTTP` 头部 + 数据，组装好 `TCP` 报文之后，就需交给下面的网络层处理。

至此，网络包的报文如下图：

![img](.img/v2-4d00211aa9bd4532b7f984b47ebafc3a_1440w.webp)

### （2）`IP`协议 | 网络层

`TCP` 模块在执行连接、收发、断开等各阶段操作时，都需要委托 `IP` 模块将数据封装成**网络包**发送给通信对象。

#### ① `IP` 包头格式

我们先看看 `IP` 报文头部的格式：

![img](.img/v2-29ffe64b9955c5d24608c9c9f2e4c789_1440w.webp)

在 `IP` 协议里面需要有**源地址 `IP` **和 **目标地址 `IP`**：

- 源地址`IP`，即是客户端输出的 `IP` 地址；
- 目标地址，即通过 `DNS `域名解析得到的 Web 服务器 `IP`。

因为 `HTTP` 是经过 `TCP` 传输的，所以在 `IP` 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 `TCP`。

#### ② 假设客户端有多个网卡，就会有多个 `IP` 地址，那 `IP` 头部的源地址应该选择哪个 `IP` 呢？

当存在多个[网卡](`HTTP`s://www.zhihu.com/search?q=网卡&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})时，在填写源地址 `IP` 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 `IP`。

在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。

![img](.img/v2-9c2e31e8aa3dc64dc068c4b05067f5be_1440w.png)

举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 `192.168.10.200`。

![img](.img/v2-657147af84c0605fef50c4d04de47d6a_1440w.webp)

首先先和第一条条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。

再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 `IP` 地址作为 `IP` 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和[子网掩码](`HTTP`s://www.zhihu.com/search?q=子网掩码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 `IP` 地址。

#### ③ `IP` 报文生成

至此，网络包的报文如下图。

![img](.img/v2-3552b3d289fc257e52cb8e5ac8ce0011_1440w.webp)

### （3）两点传输`MAC `| 数据链路层

生成了 `IP` 头部之后，接下来网络包还需要在 `IP` 头部的前面加上 **`MAC `头部**。

#### ① `MAC `包头格式

`MAC `头部是以太网使用的头部，它包含了接收方和发送方的 `MAC `地址等信息。

![img](.img/v2-5a90336f69ffad4143c88c171cf8c2e9_1440w.png)

在 `MAC `包头里需要**发送方 `MAC `地址**和**接收方目标 `MAC `地址**，用于**两点之间的传输**。

一般在 `TCP`/`IP` 通信里，`MAC `包头的**协议类型**只使用：

- `0800` ： `IP` 协议
- `0806` ： ARP 协议

#### ② `MAC `发送方和接收方如何确认?

**发送方**的 `MAC `地址获取就比较简单了，`MAC `地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 `MAC `头部就可以了。

**接收方**的 `MAC `地址就有点复杂了，只要告诉以太网对方的 `MAC `的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 `MAC `地址。

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 `IP` 地址就可以了。

#### ③ 既然知道要发给谁，按如何获取对方的 `MAC `地址呢？

不知道对方 `MAC `地址？不知道就喊呗。

此时就需要 `ARP` 协议帮我们找到路由器的 `MAC `地址。

![img](.img/v2-0347f101e41a5aefcef9ddcd39f0de05_1440w.webp)

ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 `IP` 地址是谁的？请把你的 `MAC `地址告诉我”。

然后就会有人回答：“这个 `IP` 地址是我的，我的 `MAC `地址是 XXXX”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 `MAC `地址。然后，我们将这个 `MAC `地址写入 `MAC `头部，`MAC `头部就完成了。

#### ④ 好像每次都要广播获取，这不是很麻烦吗？

放心，在后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 `MAC `地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 `MAC `地址时，则发送 ARP 广播查询。

#### ⑤ 查看 ARP 缓存内容

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。

![img](.img/v2-09d1e34a8d2ca12736af2d417fe2b927_1440w.png)

#### ⑥ `MAC `报文生成

至此，网络包的报文如下图。

![img](.img/v2-2548ae1d4dbaca6b67ee526e07b897dd_1440w.webp)



### （4）出口 | 物理层

`IP` 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。

网卡驱动从 `IP` 模块获取到包之后，会将其**复制**到网卡内的缓存区中，接着会其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

![img](.img/v2-08320694cde161e6db4df7c3cf6eea00_1440w.webp)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

最后网卡会将包转为电信号，通过网线发送出去。

## 5 交换机

下面来看一下包是如何通过交换机的。交换机的设计是将网络包**原样**转发到目的地。交换机工作在 `MAC `层，也称为**二层网络设备**。

### （1）交换机的包接收操作

首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。

然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

计算机的网卡本身具有 `MAC `地址，并通过核对收到的包的接收方 `MAC `地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 `MAC `地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有 `MAC `地址**。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 `MAC `地址是否已经在 `MAC `地址表中有记录了。

交换机的 `MAC `地址表主要包含两个信息：

- 一个是设备的 `MAC `地址，
- 另一个是该设备连接在交换机的哪个端口上。

![img](.img/v2-8c631df0c7743dcce2edfd65e6e39b23_1440w.webp)

举个例子，如果收到的包的接收方 `MAC `地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。

所以，**交换机根据 `MAC `地址表查找 `MAC `地址，然后将信号发送到相应的端口**。

### （2）当 `MAC `地址表找不到指定的 `MAC `地址会怎么样？

地址表中找不到指定的 `MAC `地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 `MAC `地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 `MAC `地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- `MAC `地址中的 `FF:FF:FF:FF:FF:FF`
- `IP` 地址中的 `255.255.255.255`

## 6 路由器

### （1）路由器与交换机的区别

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为**路由器**是基于 `IP` 设计的，俗称**三层**网络设备，路由器的各个端口都具有 `MAC `地址和 `IP` 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 `IP` 地址。

### （2）路由器基本原理

路由器的端口具有 `MAC `地址，因此它就能够成为以太网的发送方和接收方；同时还具有 `IP` 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的[以太网包](`HTTP`s://www.zhihu.com/search?q=以太网包&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

### （3）路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 `MAC `头部中的**接收方 `MAC `地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 `MAC `地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

### （4）查询路由表确定输出端口

完成包接收操作之后，路由器就会**去掉**包开头的 `MAC `头部。

**`MAC `头部的作用就是将包送达路由器**，其中的接收方 `MAC `地址就是路由器端口的 `MAC `地址。因此，当包到达路由器之后，`MAC `头部的任务就完成了，于是 `MAC `头部就会**被丢弃**。

接下来，路由器会根据 `MAC `头部后方的 `IP` 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![img](.img/v2-4ea3e321b489f464d31101bff5630547_1440w.webp)

具体的工作流程根据上图，举个例子。

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 `IP` 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` `IP` 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` `IP` 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择**[默认路由](`HTTP`s://www.zhihu.com/search?q=默认路由&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1657140394})**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。

### （5）路由器的发送操作

作者：小林coding
链接：`HTTP`s://www.zhihu.com/question/34873227/answer/1657140394
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 `IP` 地址，则这个`IP` 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 `IP` 头部中的接收方 `IP` 地址就是要转发到的目标地址，也是就终于找到 `IP` 包头里的目标地址了，说明**已抵达终点**。

知道对方的 `IP` 地址之后，接下来需要通过 `ARP` 协议根据 `IP` 地址查询 `MAC `地址，并将查询的结果作为接收方 `MAC `地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 `MAC `地址字段，这里填写输出端口的 `MAC `地址。还有一个以太类型字段，填写 `0080` （十六进制）表示 `IP` 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 `MAC `地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 `IP` 和目标 `IP` 始终是不会变的，一直变化的是 `MAC `地址**，因为需要 `MAC `地址在以太网内进行**两个设备**之间的包传输。

## 6 客户端与服务端互相拆封包

![img](.img/v2-056561275ab9c040f22d98f52dfa2216_1440w.webp)

数据包抵达服务器后，服务器会先扒开数据包的 `MAC `头部，查看是否和服务器自己的 `MAC `地址符合，符合就将包收起来。

接着继续扒开数据包的 `IP` 头，发现 `IP` 地址符合，根据 `IP` 头中协议项，知道自己上层是 `TCP` 协议。

于是，扒开 `TCP` 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。`TCP`头部里面还有端口号， `HTTP` 的服务器正在监听这个端口号。

于是，服务器自然就知道是 `HTTP` 进程想要这个包，于是就将包发给 `HTTP` 进程。

服务器的 `HTTP` 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 `HTTP` 响应报文里。

`HTTP` 响应报文也需要穿上 `TCP`、`IP`、`MAC `头部，不过这次是源地址是服务器 `IP` 地址，目的地址是客户端 `IP` 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把手的路由器，路由器扒开 `IP` 头部发现是要找城内的人，与是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 `HTTP` 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 `TCP` 四次挥手，至此双方的连接就断开了。

# Reference

1. [计算机网络基础知识总结](`HTTP`s://www.runoob.com/w3cnote/summary-of-network.html#_label0)
2. [在浏览器地址栏输入一个`URL`后回车，背后会进行哪些技术步骤？](`HTTP`s://www.zhihu.com/question/34873227/answer/518086565)
3. [`TCP`/`IP`协议中的三次握手和四次挥手](`TCP`/`IP`协议中的三次握手和四次挥手)